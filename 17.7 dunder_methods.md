In Python, special methods are a set of predefined methods you can use to enrich your classes. 

They are easy to recognize because they start and end with double underscores, for example __init__ or __str__.

These “dunders” or “special methods” in Python are also sometimes called “magic methods.” 


Dunder methods helps to operate with custom objects same way as builtin object.
Dunder methods let you emulate the behavior of built-in types. 



#### len() :  :  For example, to get the length of a string you can call len('string'). 

                But an empty class definition doesn’t support this behavior out of the box:
                
                # __len__
                
                class Employee:
                  def __init__(self,name):
                      self.emp_name = name

                  # returning length of emp_name
                  def __len__(self):
                      return len(self.emp_name)


                e = Employee('rajat')
                print(len(e))

                output : 5
                

#### str() : The “informal” or nicely printable string representation of an object. This is for the enduser.

                  # __str__
                  
                  class Employee:
                      def __init__(self,name):
                          self.emp_name = name

                      def __str__(self):
                          return f'the name of employee is {self.emp_name}'

                  e = Employee('rajat')
                  
                  print(str(e))
                  # or just 
                  print(e)
                  
                  output  : the name of employee is rajat


#### repr() : The “official” string representation of an object. This is how you would make an object of the class. 
              
              # dunder method : __repr__
              
              class Account:
                  def __init__(self,name,balance):
                      self.name = name
                      self.balance = balance

                  def __repr__(self):
                      return f'Account({self.name},{self.balance})'


              a = Account('rajat',30000)
              print(repr(a))
              
              
              output : Account(rajat,30000)



#### looping an object , if object has a iterable property, 
      
              # __getitem__()
              
              class Employee:
                  def __init__(self, name,files):
                      self.files = files
                      self.emp_name = name

                  def __getitem__(self, position):
                      return self.files[position]


              e = Employee('rajat',['file1', 'file2', 'file3', 'file4'])
              
              print(e[2]) # prints file3
              
              for file in e:
                  print(file)


              # output : 
              file1
              file2
              file3
              file4


#### 
